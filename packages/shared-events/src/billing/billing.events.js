"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LEDGER_ENTRY_CREATED_VERSION = exports.INVOICE_OVERDUE_VERSION = exports.PAYMENT_REFUNDED_VERSION = exports.PAYMENT_RECEIVED_VERSION = exports.INVOICE_PAID_VERSION = exports.INVOICE_CREATED_VERSION = exports.LEDGER_ENTRY_CREATED_EVENT = exports.INVOICE_OVERDUE_EVENT = exports.PAYMENT_REFUNDED_EVENT = exports.PAYMENT_RECEIVED_EVENT = exports.INVOICE_PAID_EVENT = exports.INVOICE_CREATED_EVENT = void 0;
exports.isInvoiceCreatedEvent = isInvoiceCreatedEvent;
exports.createInvoiceCreatedEvent = createInvoiceCreatedEvent;
exports.isInvoicePaidEvent = isInvoicePaidEvent;
exports.createInvoicePaidEvent = createInvoicePaidEvent;
exports.isPaymentReceivedEvent = isPaymentReceivedEvent;
exports.createPaymentReceivedEvent = createPaymentReceivedEvent;
exports.isPaymentRefundedEvent = isPaymentRefundedEvent;
exports.createPaymentRefundedEvent = createPaymentRefundedEvent;
exports.isInvoiceOverdueEvent = isInvoiceOverdueEvent;
exports.createInvoiceOverdueEvent = createInvoiceOverdueEvent;
exports.isLedgerEntryCreatedEvent = isLedgerEntryCreatedEvent;
exports.createLedgerEntryCreatedEvent = createLedgerEntryCreatedEvent;
exports.INVOICE_CREATED_EVENT = 'dental.billing.invoice.created';
exports.INVOICE_PAID_EVENT = 'dental.billing.invoice.paid';
exports.PAYMENT_RECEIVED_EVENT = 'dental.billing.payment.received';
exports.PAYMENT_REFUNDED_EVENT = 'dental.billing.payment.refunded';
exports.INVOICE_OVERDUE_EVENT = 'dental.billing.invoice.overdue';
exports.LEDGER_ENTRY_CREATED_EVENT = 'dental.billing.ledger-entry.created';
exports.INVOICE_CREATED_VERSION = 1;
exports.INVOICE_PAID_VERSION = 1;
exports.PAYMENT_RECEIVED_VERSION = 1;
exports.PAYMENT_REFUNDED_VERSION = 1;
exports.INVOICE_OVERDUE_VERSION = 1;
exports.LEDGER_ENTRY_CREATED_VERSION = 1;
function isInvoiceCreatedEvent(event) {
    return event.type === exports.INVOICE_CREATED_EVENT;
}
function createInvoiceCreatedEvent(payload, metadata, tenantContext) {
    if (!payload.invoiceId) {
        throw new Error('InvoiceCreatedEvent: invoiceId is required');
    }
    if (!payload.invoiceNumber || payload.invoiceNumber.trim().length === 0) {
        throw new Error('InvoiceCreatedEvent: invoiceNumber is required and cannot be empty');
    }
    if (!payload.patientId) {
        throw new Error('InvoiceCreatedEvent: patientId is required');
    }
    if (!payload.patientName || payload.patientName.trim().length === 0) {
        throw new Error('InvoiceCreatedEvent: patientName is required and cannot be empty');
    }
    if (!payload.providerId) {
        throw new Error('InvoiceCreatedEvent: providerId is required');
    }
    if (!payload.providerName || payload.providerName.trim().length === 0) {
        throw new Error('InvoiceCreatedEvent: providerName is required and cannot be empty');
    }
    if (!payload.organizationId) {
        throw new Error('InvoiceCreatedEvent: organizationId is required');
    }
    if (!payload.clinicId) {
        throw new Error('InvoiceCreatedEvent: clinicId is required');
    }
    if (!payload.tenantId) {
        throw new Error('InvoiceCreatedEvent: tenantId is required');
    }
    if (!payload.issueDate) {
        throw new Error('InvoiceCreatedEvent: issueDate is required');
    }
    if (!payload.dueDate) {
        throw new Error('InvoiceCreatedEvent: dueDate is required');
    }
    if (payload.subtotal === undefined || payload.subtotal === null) {
        throw new Error('InvoiceCreatedEvent: subtotal is required');
    }
    if (payload.subtotal < 0) {
        throw new Error('InvoiceCreatedEvent: subtotal cannot be negative');
    }
    if (payload.taxAmount === undefined || payload.taxAmount === null) {
        throw new Error('InvoiceCreatedEvent: taxAmount is required');
    }
    if (payload.taxAmount < 0) {
        throw new Error('InvoiceCreatedEvent: taxAmount cannot be negative');
    }
    if (payload.total === undefined || payload.total === null) {
        throw new Error('InvoiceCreatedEvent: total is required');
    }
    if (payload.total < 0) {
        throw new Error('InvoiceCreatedEvent: total cannot be negative');
    }
    if (!payload.currency || payload.currency.trim().length === 0) {
        throw new Error('InvoiceCreatedEvent: currency is required and cannot be empty');
    }
    if (payload.itemCount === undefined || payload.itemCount === null) {
        throw new Error('InvoiceCreatedEvent: itemCount is required');
    }
    if (payload.itemCount < 0) {
        throw new Error('InvoiceCreatedEvent: itemCount cannot be negative');
    }
    if (!payload.status) {
        throw new Error('InvoiceCreatedEvent: status is required');
    }
    if (payload.autoGenerated === undefined || payload.autoGenerated === null) {
        throw new Error('InvoiceCreatedEvent: autoGenerated is required');
    }
    if (!payload.timestamp) {
        throw new Error('InvoiceCreatedEvent: timestamp is required');
    }
    return {
        id: crypto.randomUUID(),
        type: exports.INVOICE_CREATED_EVENT,
        version: exports.INVOICE_CREATED_VERSION,
        occurredAt: new Date(),
        payload,
        metadata,
        tenantContext,
    };
}
function isInvoicePaidEvent(event) {
    return event.type === exports.INVOICE_PAID_EVENT;
}
function createInvoicePaidEvent(payload, metadata, tenantContext) {
    if (!payload.invoiceId) {
        throw new Error('InvoicePaidEvent: invoiceId is required');
    }
    if (!payload.invoiceNumber || payload.invoiceNumber.trim().length === 0) {
        throw new Error('InvoicePaidEvent: invoiceNumber is required and cannot be empty');
    }
    if (!payload.patientId) {
        throw new Error('InvoicePaidEvent: patientId is required');
    }
    if (!payload.paymentId) {
        throw new Error('InvoicePaidEvent: paymentId is required');
    }
    if (!payload.organizationId) {
        throw new Error('InvoicePaidEvent: organizationId is required');
    }
    if (!payload.clinicId) {
        throw new Error('InvoicePaidEvent: clinicId is required');
    }
    if (!payload.tenantId) {
        throw new Error('InvoicePaidEvent: tenantId is required');
    }
    if (!payload.paidDate) {
        throw new Error('InvoicePaidEvent: paidDate is required');
    }
    if (payload.paidAmount === undefined || payload.paidAmount === null) {
        throw new Error('InvoicePaidEvent: paidAmount is required');
    }
    if (payload.paidAmount <= 0) {
        throw new Error('InvoicePaidEvent: paidAmount must be greater than zero');
    }
    if (!payload.paymentMethod) {
        throw new Error('InvoicePaidEvent: paymentMethod is required');
    }
    if (payload.previousBalance === undefined || payload.previousBalance === null) {
        throw new Error('InvoicePaidEvent: previousBalance is required');
    }
    if (payload.previousBalance < 0) {
        throw new Error('InvoicePaidEvent: previousBalance cannot be negative');
    }
    if (payload.newBalance === undefined || payload.newBalance === null) {
        throw new Error('InvoicePaidEvent: newBalance is required');
    }
    if (payload.newBalance < 0) {
        throw new Error('InvoicePaidEvent: newBalance cannot be negative');
    }
    if (payload.isFullyPaid === undefined || payload.isFullyPaid === null) {
        throw new Error('InvoicePaidEvent: isFullyPaid is required');
    }
    if (!payload.currency || payload.currency.trim().length === 0) {
        throw new Error('InvoicePaidEvent: currency is required and cannot be empty');
    }
    if (!payload.timestamp) {
        throw new Error('InvoicePaidEvent: timestamp is required');
    }
    const expectedNewBalance = payload.previousBalance - payload.paidAmount;
    const tolerance = 0.01;
    if (Math.abs(payload.newBalance - expectedNewBalance) > tolerance) {
        throw new Error(`InvoicePaidEvent: newBalance (${payload.newBalance}) does not match previousBalance (${payload.previousBalance}) - paidAmount (${payload.paidAmount}) = ${expectedNewBalance}`);
    }
    if (payload.isFullyPaid && payload.newBalance > tolerance) {
        throw new Error(`InvoicePaidEvent: isFullyPaid is true but newBalance (${payload.newBalance}) is greater than zero`);
    }
    return {
        id: crypto.randomUUID(),
        type: exports.INVOICE_PAID_EVENT,
        version: exports.INVOICE_PAID_VERSION,
        occurredAt: new Date(),
        payload,
        metadata,
        tenantContext,
    };
}
function isPaymentReceivedEvent(event) {
    return event.type === exports.PAYMENT_RECEIVED_EVENT;
}
function createPaymentReceivedEvent(payload, metadata, tenantContext) {
    if (!payload.paymentId) {
        throw new Error('PaymentReceivedEvent: paymentId is required');
    }
    if (!payload.patientId) {
        throw new Error('PaymentReceivedEvent: patientId is required');
    }
    if (!payload.organizationId) {
        throw new Error('PaymentReceivedEvent: organizationId is required');
    }
    if (!payload.clinicId) {
        throw new Error('PaymentReceivedEvent: clinicId is required');
    }
    if (!payload.tenantId) {
        throw new Error('PaymentReceivedEvent: tenantId is required');
    }
    if (payload.amount === undefined || payload.amount === null) {
        throw new Error('PaymentReceivedEvent: amount is required');
    }
    if (payload.amount <= 0) {
        throw new Error('PaymentReceivedEvent: amount must be greater than zero');
    }
    if (!payload.currency || payload.currency.trim().length === 0) {
        throw new Error('PaymentReceivedEvent: currency is required and cannot be empty');
    }
    if (!payload.paymentMethod) {
        throw new Error('PaymentReceivedEvent: paymentMethod is required');
    }
    if (!payload.paymentDate) {
        throw new Error('PaymentReceivedEvent: paymentDate is required');
    }
    if (!payload.processedBy) {
        throw new Error('PaymentReceivedEvent: processedBy is required');
    }
    if (!payload.timestamp) {
        throw new Error('PaymentReceivedEvent: timestamp is required');
    }
    return {
        id: crypto.randomUUID(),
        type: exports.PAYMENT_RECEIVED_EVENT,
        version: exports.PAYMENT_RECEIVED_VERSION,
        occurredAt: new Date(),
        payload,
        metadata,
        tenantContext,
    };
}
function isPaymentRefundedEvent(event) {
    return event.type === exports.PAYMENT_REFUNDED_EVENT;
}
function createPaymentRefundedEvent(payload, metadata, tenantContext) {
    if (!payload.paymentId) {
        throw new Error('PaymentRefundedEvent: paymentId is required');
    }
    if (!payload.patientId) {
        throw new Error('PaymentRefundedEvent: patientId is required');
    }
    if (!payload.organizationId) {
        throw new Error('PaymentRefundedEvent: organizationId is required');
    }
    if (!payload.clinicId) {
        throw new Error('PaymentRefundedEvent: clinicId is required');
    }
    if (!payload.tenantId) {
        throw new Error('PaymentRefundedEvent: tenantId is required');
    }
    if (payload.refundAmount === undefined || payload.refundAmount === null) {
        throw new Error('PaymentRefundedEvent: refundAmount is required');
    }
    if (payload.refundAmount <= 0) {
        throw new Error('PaymentRefundedEvent: refundAmount must be greater than zero');
    }
    if (payload.originalAmount === undefined || payload.originalAmount === null) {
        throw new Error('PaymentRefundedEvent: originalAmount is required');
    }
    if (payload.originalAmount <= 0) {
        throw new Error('PaymentRefundedEvent: originalAmount must be greater than zero');
    }
    if (payload.refundAmount > payload.originalAmount) {
        throw new Error(`PaymentRefundedEvent: refundAmount (${payload.refundAmount}) cannot exceed originalAmount (${payload.originalAmount})`);
    }
    if (!payload.currency || payload.currency.trim().length === 0) {
        throw new Error('PaymentRefundedEvent: currency is required and cannot be empty');
    }
    if (!payload.refundReason) {
        throw new Error('PaymentRefundedEvent: refundReason is required');
    }
    if (!payload.refundedBy) {
        throw new Error('PaymentRefundedEvent: refundedBy is required');
    }
    if (!payload.refundDate) {
        throw new Error('PaymentRefundedEvent: refundDate is required');
    }
    if (!payload.timestamp) {
        throw new Error('PaymentRefundedEvent: timestamp is required');
    }
    return {
        id: crypto.randomUUID(),
        type: exports.PAYMENT_REFUNDED_EVENT,
        version: exports.PAYMENT_REFUNDED_VERSION,
        occurredAt: new Date(),
        payload,
        metadata,
        tenantContext,
    };
}
function isInvoiceOverdueEvent(event) {
    return event.type === exports.INVOICE_OVERDUE_EVENT;
}
function createInvoiceOverdueEvent(payload, metadata, tenantContext) {
    if (!payload.invoiceId) {
        throw new Error('InvoiceOverdueEvent: invoiceId is required');
    }
    if (!payload.invoiceNumber || payload.invoiceNumber.trim().length === 0) {
        throw new Error('InvoiceOverdueEvent: invoiceNumber is required and cannot be empty');
    }
    if (!payload.patientId) {
        throw new Error('InvoiceOverdueEvent: patientId is required');
    }
    if (!payload.patientName || payload.patientName.trim().length === 0) {
        throw new Error('InvoiceOverdueEvent: patientName is required and cannot be empty');
    }
    if (!payload.organizationId) {
        throw new Error('InvoiceOverdueEvent: organizationId is required');
    }
    if (!payload.clinicId) {
        throw new Error('InvoiceOverdueEvent: clinicId is required');
    }
    if (!payload.tenantId) {
        throw new Error('InvoiceOverdueEvent: tenantId is required');
    }
    if (!payload.dueDate) {
        throw new Error('InvoiceOverdueEvent: dueDate is required');
    }
    if (payload.daysOverdue === undefined || payload.daysOverdue === null) {
        throw new Error('InvoiceOverdueEvent: daysOverdue is required');
    }
    if (payload.daysOverdue < 0) {
        throw new Error('InvoiceOverdueEvent: daysOverdue cannot be negative');
    }
    if (payload.outstandingBalance === undefined || payload.outstandingBalance === null) {
        throw new Error('InvoiceOverdueEvent: outstandingBalance is required');
    }
    if (payload.outstandingBalance <= 0) {
        throw new Error('InvoiceOverdueEvent: outstandingBalance must be greater than zero for overdue invoices');
    }
    if (payload.totalAmount === undefined || payload.totalAmount === null) {
        throw new Error('InvoiceOverdueEvent: totalAmount is required');
    }
    if (payload.totalAmount <= 0) {
        throw new Error('InvoiceOverdueEvent: totalAmount must be greater than zero');
    }
    if (payload.outstandingBalance > payload.totalAmount) {
        throw new Error(`InvoiceOverdueEvent: outstandingBalance (${payload.outstandingBalance}) cannot exceed totalAmount (${payload.totalAmount})`);
    }
    if (!payload.currency || payload.currency.trim().length === 0) {
        throw new Error('InvoiceOverdueEvent: currency is required and cannot be empty');
    }
    if (!payload.timestamp) {
        throw new Error('InvoiceOverdueEvent: timestamp is required');
    }
    return {
        id: crypto.randomUUID(),
        type: exports.INVOICE_OVERDUE_EVENT,
        version: exports.INVOICE_OVERDUE_VERSION,
        occurredAt: new Date(),
        payload,
        metadata,
        tenantContext,
    };
}
function isLedgerEntryCreatedEvent(event) {
    return event.type === exports.LEDGER_ENTRY_CREATED_EVENT;
}
function createLedgerEntryCreatedEvent(payload, metadata, tenantContext) {
    if (!payload.ledgerEntryId) {
        throw new Error('LedgerEntryCreatedEvent: ledgerEntryId is required');
    }
    if (!payload.organizationId) {
        throw new Error('LedgerEntryCreatedEvent: organizationId is required');
    }
    if (!payload.clinicId) {
        throw new Error('LedgerEntryCreatedEvent: clinicId is required');
    }
    if (!payload.tenantId) {
        throw new Error('LedgerEntryCreatedEvent: tenantId is required');
    }
    if (!payload.entryType) {
        throw new Error('LedgerEntryCreatedEvent: entryType is required');
    }
    if (payload.entryType !== 'DEBIT' && payload.entryType !== 'CREDIT') {
        throw new Error('LedgerEntryCreatedEvent: entryType must be either DEBIT or CREDIT');
    }
    if (!payload.account || payload.account.trim().length === 0) {
        throw new Error('LedgerEntryCreatedEvent: account is required and cannot be empty');
    }
    if (!payload.accountCode || payload.accountCode.trim().length === 0) {
        throw new Error('LedgerEntryCreatedEvent: accountCode is required and cannot be empty');
    }
    if (payload.amount === undefined || payload.amount === null) {
        throw new Error('LedgerEntryCreatedEvent: amount is required');
    }
    if (payload.amount <= 0) {
        throw new Error('LedgerEntryCreatedEvent: amount must be greater than zero');
    }
    if (!payload.currency || payload.currency.trim().length === 0) {
        throw new Error('LedgerEntryCreatedEvent: currency is required and cannot be empty');
    }
    if (!payload.description || payload.description.trim().length === 0) {
        throw new Error('LedgerEntryCreatedEvent: description is required and cannot be empty');
    }
    if (!payload.referenceId) {
        throw new Error('LedgerEntryCreatedEvent: referenceId is required');
    }
    if (!payload.referenceType) {
        throw new Error('LedgerEntryCreatedEvent: referenceType is required');
    }
    if (!payload.timestamp) {
        throw new Error('LedgerEntryCreatedEvent: timestamp is required');
    }
    return {
        id: crypto.randomUUID(),
        type: exports.LEDGER_ENTRY_CREATED_EVENT,
        version: exports.LEDGER_ENTRY_CREATED_VERSION,
        occurredAt: new Date(),
        payload,
        metadata,
        tenantContext,
    };
}
//# sourceMappingURL=billing.events.js.map