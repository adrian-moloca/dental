/**
 * Billing Events
 *
 * Domain events for billing operations, payment processing, invoice management,
 * and financial ledger tracking. These events maintain financial integrity,
 * enable real-time revenue tracking, and support regulatory compliance.
 *
 * These events are consumed by:
 * - Analytics Platform (revenue tracking, AR aging, payment trends)
 * - Automation Engine (overdue reminders, payment confirmations, follow-ups)
 * - Patient Portal (payment notifications, invoice status updates)
 * - Accounting Systems (QuickBooks, Xero integration, ledger synchronization)
 * - Finance Module (double-entry accounting, revenue recognition, reconciliation)
 * - Compliance Systems (audit trails, financial reporting, tax compliance)
 * - Commission Engine (provider commission calculations)
 *
 * @module shared-events/billing
 */

import type { UUID, OrganizationId, ClinicId, ISODateString } from '@dentalos/shared-types';
import type { EventEnvelope } from '../envelope/event-envelope';

// ============================================================================
// EVENT TYPE CONSTANTS
// ============================================================================

/**
 * Invoice created event type constant
 */
export const INVOICE_CREATED_EVENT = 'dental.billing.invoice.created' as const;

/**
 * Invoice paid event type constant
 */
export const INVOICE_PAID_EVENT = 'dental.billing.invoice.paid' as const;

/**
 * Payment received event type constant
 */
export const PAYMENT_RECEIVED_EVENT = 'dental.billing.payment.received' as const;

/**
 * Payment refunded event type constant
 */
export const PAYMENT_REFUNDED_EVENT = 'dental.billing.payment.refunded' as const;

/**
 * Invoice overdue event type constant
 */
export const INVOICE_OVERDUE_EVENT = 'dental.billing.invoice.overdue' as const;

/**
 * Ledger entry created event type constant
 */
export const LEDGER_ENTRY_CREATED_EVENT = 'dental.billing.ledger-entry.created' as const;

// ============================================================================
// EVENT VERSION CONSTANTS
// ============================================================================

export const INVOICE_CREATED_VERSION = 1;
export const INVOICE_PAID_VERSION = 1;
export const PAYMENT_RECEIVED_VERSION = 1;
export const PAYMENT_REFUNDED_VERSION = 1;
export const INVOICE_OVERDUE_VERSION = 1;
export const LEDGER_ENTRY_CREATED_VERSION = 1;

// ============================================================================
// ENUMERATIONS AND SHARED TYPES
// ============================================================================

/**
 * Invoice status enumeration
 */
export type InvoiceStatus =
  | 'DRAFT' // Invoice created but not issued
  | 'ISSUED' // Invoice issued to patient/insurer
  | 'PARTIALLY_PAID' // Invoice partially paid
  | 'PAID' // Invoice fully paid
  | 'OVERDUE' // Invoice past due date
  | 'CANCELLED' // Invoice cancelled
  | 'VOID'; // Invoice voided (accounting purposes)

/**
 * Payment method enumeration
 */
export type PaymentMethod =
  | 'CASH'
  | 'CREDIT_CARD'
  | 'DEBIT_CARD'
  | 'BANK_TRANSFER'
  | 'CHECK'
  | 'INSURANCE'
  | 'ONLINE'
  | 'MOBILE_PAYMENT'
  | 'OTHER';

/**
 * Ledger entry type enumeration
 * Used for double-entry accounting
 */
export type LedgerEntryType = 'DEBIT' | 'CREDIT';

/**
 * Refund reason enumeration
 */
export type RefundReason =
  | 'OVERPAYMENT'
  | 'DUPLICATE_PAYMENT'
  | 'SERVICE_CANCELLED'
  | 'INSURANCE_ADJUSTMENT'
  | 'PATIENT_REQUEST'
  | 'BILLING_ERROR'
  | 'TREATMENT_REVERSAL'
  | 'OTHER';

/**
 * Currency code (ISO 4217)
 */
export type CurrencyCode = 'RON' | 'EUR' | 'USD' | 'GBP' | string;

// ============================================================================
// 1. INVOICE CREATED EVENT
// ============================================================================

/**
 * Invoice created event payload
 *
 * Published when a new invoice is created for patient services.
 * Consumed by analytics (revenue tracking), patient portal (notifications),
 * and accounting systems (revenue recognition).
 *
 * @example
 * ```typescript
 * const payload: InvoiceCreatedPayload = {
 *   invoiceId: '123e4567-e89b-12d3-a456-426614174000',
 *   invoiceNumber: 'INV-2025-001234',
 *   patientId: 'patient-123',
 *   patientName: 'John Doe',
 *   providerId: 'provider-456',
 *   providerName: 'Dr. Jane Smith',
 *   organizationId: 'org-789',
 *   clinicId: 'clinic-101',
 *   tenantId: 'tenant-789',
 *   appointmentId: 'appt-555',
 *   issueDate: '2025-11-21T10:00:00Z',
 *   dueDate: '2025-12-21T10:00:00Z',
 *   subtotal: 1200.00,
 *   taxAmount: 228.00,
 *   total: 1428.00,
 *   currency: 'RON',
 *   itemCount: 3,
 *   status: 'ISSUED',
 *   autoGenerated: true,
 *   timestamp: '2025-11-21T10:00:00Z',
 * };
 * ```
 */
export interface InvoiceCreatedPayload {
  /** Unique invoice identifier */
  invoiceId: UUID;

  /** Human-readable invoice number (sequential, formatted) */
  invoiceNumber: string;

  /** Patient receiving the invoice */
  patientId: UUID;

  /** Patient name for display purposes */
  patientName: string;

  /** Provider who performed the services */
  providerId: UUID;

  /** Provider name for display purposes */
  providerName: string;

  /** Organization ID (tenant context) */
  organizationId: OrganizationId;

  /** Clinic ID where services were provided */
  clinicId: ClinicId;

  /** Unified tenant identifier for data partitioning */
  tenantId: string;

  /** Associated appointment ID if applicable */
  appointmentId?: UUID;

  /** Associated treatment plan ID if applicable */
  treatmentPlanId?: UUID;

  /** Invoice issue date (when invoice was issued to patient) */
  issueDate: ISODateString;

  /** Payment due date */
  dueDate: ISODateString;

  /** Subtotal before taxes and discounts */
  subtotal: number;

  /** Total tax amount (VAT, sales tax, etc.) */
  taxAmount: number;

  /** Total discount amount applied */
  discountAmount?: number;

  /** Final total amount due */
  total: number;

  /** Currency code (ISO 4217) */
  currency: CurrencyCode;

  /** Number of line items on the invoice */
  itemCount: number;

  /** Current invoice status */
  status: InvoiceStatus;

  /** Whether invoice was auto-generated from appointment/treatment plan */
  autoGenerated: boolean;

  /** Patient billing address */
  billingAddress?: string;

  /** Patient tax ID or CUI (Romanian fiscal code) */
  patientTaxId?: string;

  /** Payment terms in days */
  paymentTermsDays?: number;

  /** Invoice notes or special instructions */
  notes?: string;

  /** e-Factura integration ID (Romanian invoicing system) */
  eFakturaId?: string;

  /** Timestamp when invoice was created */
  timestamp: ISODateString;

  /** Custom metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Invoice created event envelope
 */
export type InvoiceCreatedEvent = EventEnvelope<InvoiceCreatedPayload>;

/**
 * Type guard to check if an event is an InvoiceCreatedEvent
 *
 * @param event - The event to check
 * @returns True if the event is an InvoiceCreatedEvent
 */
export function isInvoiceCreatedEvent(
  event: EventEnvelope<unknown>
): event is InvoiceCreatedEvent {
  return event.type === INVOICE_CREATED_EVENT;
}

/**
 * Factory function to create an InvoiceCreatedEvent
 *
 * Validates required fields and generates a complete event envelope.
 *
 * @param payload - The event payload
 * @param metadata - Event metadata
 * @param tenantContext - Tenant context
 * @returns Complete event envelope
 * @throws {Error} If required fields are missing or invalid
 */
export function createInvoiceCreatedEvent(
  payload: InvoiceCreatedPayload,
  metadata: EventEnvelope<unknown>['metadata'],
  tenantContext: EventEnvelope<unknown>['tenantContext']
): InvoiceCreatedEvent {
  // Validate critical required fields
  if (!payload.invoiceId) {
    throw new Error('InvoiceCreatedEvent: invoiceId is required');
  }
  if (!payload.invoiceNumber || payload.invoiceNumber.trim().length === 0) {
    throw new Error('InvoiceCreatedEvent: invoiceNumber is required and cannot be empty');
  }
  if (!payload.patientId) {
    throw new Error('InvoiceCreatedEvent: patientId is required');
  }
  if (!payload.patientName || payload.patientName.trim().length === 0) {
    throw new Error('InvoiceCreatedEvent: patientName is required and cannot be empty');
  }
  if (!payload.providerId) {
    throw new Error('InvoiceCreatedEvent: providerId is required');
  }
  if (!payload.providerName || payload.providerName.trim().length === 0) {
    throw new Error('InvoiceCreatedEvent: providerName is required and cannot be empty');
  }
  if (!payload.organizationId) {
    throw new Error('InvoiceCreatedEvent: organizationId is required');
  }
  if (!payload.clinicId) {
    throw new Error('InvoiceCreatedEvent: clinicId is required');
  }
  if (!payload.tenantId) {
    throw new Error('InvoiceCreatedEvent: tenantId is required');
  }
  if (!payload.issueDate) {
    throw new Error('InvoiceCreatedEvent: issueDate is required');
  }
  if (!payload.dueDate) {
    throw new Error('InvoiceCreatedEvent: dueDate is required');
  }
  if (payload.subtotal === undefined || payload.subtotal === null) {
    throw new Error('InvoiceCreatedEvent: subtotal is required');
  }
  if (payload.subtotal < 0) {
    throw new Error('InvoiceCreatedEvent: subtotal cannot be negative');
  }
  if (payload.taxAmount === undefined || payload.taxAmount === null) {
    throw new Error('InvoiceCreatedEvent: taxAmount is required');
  }
  if (payload.taxAmount < 0) {
    throw new Error('InvoiceCreatedEvent: taxAmount cannot be negative');
  }
  if (payload.total === undefined || payload.total === null) {
    throw new Error('InvoiceCreatedEvent: total is required');
  }
  if (payload.total < 0) {
    throw new Error('InvoiceCreatedEvent: total cannot be negative');
  }
  if (!payload.currency || payload.currency.trim().length === 0) {
    throw new Error('InvoiceCreatedEvent: currency is required and cannot be empty');
  }
  if (payload.itemCount === undefined || payload.itemCount === null) {
    throw new Error('InvoiceCreatedEvent: itemCount is required');
  }
  if (payload.itemCount < 0) {
    throw new Error('InvoiceCreatedEvent: itemCount cannot be negative');
  }
  if (!payload.status) {
    throw new Error('InvoiceCreatedEvent: status is required');
  }
  if (payload.autoGenerated === undefined || payload.autoGenerated === null) {
    throw new Error('InvoiceCreatedEvent: autoGenerated is required');
  }
  if (!payload.timestamp) {
    throw new Error('InvoiceCreatedEvent: timestamp is required');
  }

  return {
    id: crypto.randomUUID() as UUID,
    type: INVOICE_CREATED_EVENT,
    version: INVOICE_CREATED_VERSION,
    occurredAt: new Date(),
    payload,
    metadata,
    tenantContext,
  };
}

// ============================================================================
// 2. INVOICE PAID EVENT
// ============================================================================

/**
 * Invoice paid event payload
 *
 * Published when an invoice receives a payment (partial or full).
 * Consumed by analytics (cash flow tracking), patient portal (payment confirmation),
 * and automation engine (payment receipts, notifications).
 *
 * @example
 * ```typescript
 * const payload: InvoicePaidPayload = {
 *   invoiceId: '123e4567-e89b-12d3-a456-426614174000',
 *   invoiceNumber: 'INV-2025-001234',
 *   patientId: 'patient-123',
 *   paymentId: 'payment-789',
 *   organizationId: 'org-789',
 *   clinicId: 'clinic-101',
 *   tenantId: 'tenant-789',
 *   paidDate: '2025-11-22T14:30:00Z',
 *   paidAmount: 500.00,
 *   paymentMethod: 'CREDIT_CARD',
 *   previousBalance: 1428.00,
 *   newBalance: 928.00,
 *   isFullyPaid: false,
 *   currency: 'RON',
 *   timestamp: '2025-11-22T14:30:00Z',
 * };
 * ```
 */
export interface InvoicePaidPayload {
  /** Invoice identifier */
  invoiceId: UUID;

  /** Invoice number for display */
  invoiceNumber: string;

  /** Patient who made the payment */
  patientId: UUID;

  /** Payment record identifier */
  paymentId: UUID;

  /** Organization ID (tenant context) */
  organizationId: OrganizationId;

  /** Clinic ID */
  clinicId: ClinicId;

  /** Unified tenant identifier for data partitioning */
  tenantId: string;

  /** Date when payment was made */
  paidDate: ISODateString;

  /** Amount paid in this payment */
  paidAmount: number;

  /** Payment method used */
  paymentMethod: PaymentMethod;

  /** Outstanding balance before this payment */
  previousBalance: number;

  /** Remaining balance after this payment */
  newBalance: number;

  /** Whether invoice is now fully paid */
  isFullyPaid: boolean;

  /** Currency code (ISO 4217) */
  currency: CurrencyCode;

  /** Payment processor transaction ID */
  transactionId?: string;

  /** Payment confirmation number */
  confirmationNumber?: string;

  /** Notes about the payment */
  notes?: string;

  /** Timestamp when payment was recorded */
  timestamp: ISODateString;

  /** Custom metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Invoice paid event envelope
 */
export type InvoicePaidEvent = EventEnvelope<InvoicePaidPayload>;

/**
 * Type guard to check if an event is an InvoicePaidEvent
 *
 * @param event - The event to check
 * @returns True if the event is an InvoicePaidEvent
 */
export function isInvoicePaidEvent(
  event: EventEnvelope<unknown>
): event is InvoicePaidEvent {
  return event.type === INVOICE_PAID_EVENT;
}

/**
 * Factory function to create an InvoicePaidEvent
 *
 * Validates required fields and generates a complete event envelope.
 *
 * @param payload - The event payload
 * @param metadata - Event metadata
 * @param tenantContext - Tenant context
 * @returns Complete event envelope
 * @throws {Error} If required fields are missing or invalid
 */
export function createInvoicePaidEvent(
  payload: InvoicePaidPayload,
  metadata: EventEnvelope<unknown>['metadata'],
  tenantContext: EventEnvelope<unknown>['tenantContext']
): InvoicePaidEvent {
  // Validate critical required fields
  if (!payload.invoiceId) {
    throw new Error('InvoicePaidEvent: invoiceId is required');
  }
  if (!payload.invoiceNumber || payload.invoiceNumber.trim().length === 0) {
    throw new Error('InvoicePaidEvent: invoiceNumber is required and cannot be empty');
  }
  if (!payload.patientId) {
    throw new Error('InvoicePaidEvent: patientId is required');
  }
  if (!payload.paymentId) {
    throw new Error('InvoicePaidEvent: paymentId is required');
  }
  if (!payload.organizationId) {
    throw new Error('InvoicePaidEvent: organizationId is required');
  }
  if (!payload.clinicId) {
    throw new Error('InvoicePaidEvent: clinicId is required');
  }
  if (!payload.tenantId) {
    throw new Error('InvoicePaidEvent: tenantId is required');
  }
  if (!payload.paidDate) {
    throw new Error('InvoicePaidEvent: paidDate is required');
  }
  if (payload.paidAmount === undefined || payload.paidAmount === null) {
    throw new Error('InvoicePaidEvent: paidAmount is required');
  }
  if (payload.paidAmount <= 0) {
    throw new Error('InvoicePaidEvent: paidAmount must be greater than zero');
  }
  if (!payload.paymentMethod) {
    throw new Error('InvoicePaidEvent: paymentMethod is required');
  }
  if (payload.previousBalance === undefined || payload.previousBalance === null) {
    throw new Error('InvoicePaidEvent: previousBalance is required');
  }
  if (payload.previousBalance < 0) {
    throw new Error('InvoicePaidEvent: previousBalance cannot be negative');
  }
  if (payload.newBalance === undefined || payload.newBalance === null) {
    throw new Error('InvoicePaidEvent: newBalance is required');
  }
  if (payload.newBalance < 0) {
    throw new Error('InvoicePaidEvent: newBalance cannot be negative');
  }
  if (payload.isFullyPaid === undefined || payload.isFullyPaid === null) {
    throw new Error('InvoicePaidEvent: isFullyPaid is required');
  }
  if (!payload.currency || payload.currency.trim().length === 0) {
    throw new Error('InvoicePaidEvent: currency is required and cannot be empty');
  }
  if (!payload.timestamp) {
    throw new Error('InvoicePaidEvent: timestamp is required');
  }

  // Validate business logic: previousBalance - paidAmount should equal newBalance
  const expectedNewBalance = payload.previousBalance - payload.paidAmount;
  const tolerance = 0.01; // Allow 1 cent rounding difference
  if (Math.abs(payload.newBalance - expectedNewBalance) > tolerance) {
    throw new Error(
      `InvoicePaidEvent: newBalance (${payload.newBalance}) does not match previousBalance (${payload.previousBalance}) - paidAmount (${payload.paidAmount}) = ${expectedNewBalance}`
    );
  }

  // Validate isFullyPaid matches newBalance
  if (payload.isFullyPaid && payload.newBalance > tolerance) {
    throw new Error(
      `InvoicePaidEvent: isFullyPaid is true but newBalance (${payload.newBalance}) is greater than zero`
    );
  }

  return {
    id: crypto.randomUUID() as UUID,
    type: INVOICE_PAID_EVENT,
    version: INVOICE_PAID_VERSION,
    occurredAt: new Date(),
    payload,
    metadata,
    tenantContext,
  };
}

// ============================================================================
// 3. PAYMENT RECEIVED EVENT
// ============================================================================

/**
 * Payment received event payload
 *
 * Published when a payment is received (may apply to one or multiple invoices).
 * Consumed by analytics (revenue tracking), accounting systems (cash receipts),
 * and automation engine (payment confirmations, receipts).
 *
 * @example
 * ```typescript
 * const payload: PaymentReceivedPayload = {
 *   paymentId: 'payment-789',
 *   invoiceId: '123e4567-e89b-12d3-a456-426614174000',
 *   patientId: 'patient-123',
 *   organizationId: 'org-789',
 *   clinicId: 'clinic-101',
 *   tenantId: 'tenant-789',
 *   amount: 500.00,
 *   currency: 'RON',
 *   paymentMethod: 'CREDIT_CARD',
 *   paymentDate: '2025-11-22T14:30:00Z',
 *   transactionId: 'txn_abc123',
 *   confirmationNumber: 'CONF-98765',
 *   processedBy: 'user-456',
 *   timestamp: '2025-11-22T14:30:00Z',
 * };
 * ```
 */
export interface PaymentReceivedPayload {
  /** Unique payment identifier */
  paymentId: UUID;

  /** Invoice the payment applies to (optional if payment on account) */
  invoiceId?: UUID;

  /** Invoice number for display */
  invoiceNumber?: string;

  /** Patient who made the payment */
  patientId: UUID;

  /** Organization ID (tenant context) */
  organizationId: OrganizationId;

  /** Clinic ID where payment was received */
  clinicId: ClinicId;

  /** Unified tenant identifier for data partitioning */
  tenantId: string;

  /** Payment amount */
  amount: number;

  /** Currency code (ISO 4217) */
  currency: CurrencyCode;

  /** Payment method used */
  paymentMethod: PaymentMethod;

  /** Date when payment was made */
  paymentDate: ISODateString;

  /** Payment processor transaction ID */
  transactionId?: string;

  /** Payment confirmation number */
  confirmationNumber?: string;

  /** User who processed the payment */
  processedBy: UUID;

  /** Processor name for display */
  processedByName?: string;

  /** Payment reference or description */
  reference?: string;

  /** Payment notes */
  notes?: string;

  /** Payment gateway or processor name */
  paymentGateway?: string;

  /** Whether payment was processed successfully */
  isSuccessful?: boolean;

  /** Payment processor response/status */
  processorStatus?: string;

  /** Timestamp when payment was received */
  timestamp: ISODateString;

  /** Custom metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Payment received event envelope
 */
export type PaymentReceivedEvent = EventEnvelope<PaymentReceivedPayload>;

/**
 * Type guard to check if an event is a PaymentReceivedEvent
 *
 * @param event - The event to check
 * @returns True if the event is a PaymentReceivedEvent
 */
export function isPaymentReceivedEvent(
  event: EventEnvelope<unknown>
): event is PaymentReceivedEvent {
  return event.type === PAYMENT_RECEIVED_EVENT;
}

/**
 * Factory function to create a PaymentReceivedEvent
 *
 * Validates required fields and generates a complete event envelope.
 *
 * @param payload - The event payload
 * @param metadata - Event metadata
 * @param tenantContext - Tenant context
 * @returns Complete event envelope
 * @throws {Error} If required fields are missing or invalid
 */
export function createPaymentReceivedEvent(
  payload: PaymentReceivedPayload,
  metadata: EventEnvelope<unknown>['metadata'],
  tenantContext: EventEnvelope<unknown>['tenantContext']
): PaymentReceivedEvent {
  // Validate critical required fields
  if (!payload.paymentId) {
    throw new Error('PaymentReceivedEvent: paymentId is required');
  }
  if (!payload.patientId) {
    throw new Error('PaymentReceivedEvent: patientId is required');
  }
  if (!payload.organizationId) {
    throw new Error('PaymentReceivedEvent: organizationId is required');
  }
  if (!payload.clinicId) {
    throw new Error('PaymentReceivedEvent: clinicId is required');
  }
  if (!payload.tenantId) {
    throw new Error('PaymentReceivedEvent: tenantId is required');
  }
  if (payload.amount === undefined || payload.amount === null) {
    throw new Error('PaymentReceivedEvent: amount is required');
  }
  if (payload.amount <= 0) {
    throw new Error('PaymentReceivedEvent: amount must be greater than zero');
  }
  if (!payload.currency || payload.currency.trim().length === 0) {
    throw new Error('PaymentReceivedEvent: currency is required and cannot be empty');
  }
  if (!payload.paymentMethod) {
    throw new Error('PaymentReceivedEvent: paymentMethod is required');
  }
  if (!payload.paymentDate) {
    throw new Error('PaymentReceivedEvent: paymentDate is required');
  }
  if (!payload.processedBy) {
    throw new Error('PaymentReceivedEvent: processedBy is required');
  }
  if (!payload.timestamp) {
    throw new Error('PaymentReceivedEvent: timestamp is required');
  }

  return {
    id: crypto.randomUUID() as UUID,
    type: PAYMENT_RECEIVED_EVENT,
    version: PAYMENT_RECEIVED_VERSION,
    occurredAt: new Date(),
    payload,
    metadata,
    tenantContext,
  };
}

// ============================================================================
// 4. PAYMENT REFUNDED EVENT
// ============================================================================

/**
 * Payment refunded event payload
 *
 * Published when a payment is refunded (partial or full).
 * Consumed by analytics (refund tracking), accounting systems (cash flow),
 * automation engine (refund notifications), and compliance systems (audit trails).
 *
 * @example
 * ```typescript
 * const payload: PaymentRefundedPayload = {
 *   paymentId: 'payment-789',
 *   refundId: 'refund-321',
 *   invoiceId: '123e4567-e89b-12d3-a456-426614174000',
 *   patientId: 'patient-123',
 *   organizationId: 'org-789',
 *   clinicId: 'clinic-101',
 *   tenantId: 'tenant-789',
 *   refundAmount: 200.00,
 *   originalAmount: 500.00,
 *   currency: 'RON',
 *   refundReason: 'OVERPAYMENT',
 *   refundedBy: 'user-456',
 *   refundDate: '2025-11-23T10:00:00Z',
 *   timestamp: '2025-11-23T10:00:00Z',
 * };
 * ```
 */
export interface PaymentRefundedPayload {
  /** Original payment identifier */
  paymentId: UUID;

  /** Unique refund identifier */
  refundId?: UUID;

  /** Invoice the refund applies to */
  invoiceId?: UUID;

  /** Invoice number for display */
  invoiceNumber?: string;

  /** Patient receiving the refund */
  patientId: UUID;

  /** Organization ID (tenant context) */
  organizationId: OrganizationId;

  /** Clinic ID */
  clinicId: ClinicId;

  /** Unified tenant identifier for data partitioning */
  tenantId: string;

  /** Refund amount */
  refundAmount: number;

  /** Original payment amount */
  originalAmount: number;

  /** Currency code (ISO 4217) */
  currency: CurrencyCode;

  /** Reason for the refund */
  refundReason: RefundReason;

  /** User who processed the refund */
  refundedBy: UUID;

  /** Refunded by user name for display */
  refundedByName?: string;

  /** Date when refund was processed */
  refundDate: ISODateString;

  /** Refund transaction ID from payment processor */
  refundTransactionId?: string;

  /** Payment method for refund (may differ from original) */
  refundMethod?: PaymentMethod;

  /** Refund notes or description */
  notes?: string;

  /** Whether refund was successfully processed */
  isSuccessful?: boolean;

  /** Payment processor refund status */
  processorStatus?: string;

  /** Timestamp when refund was recorded */
  timestamp: ISODateString;

  /** Custom metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Payment refunded event envelope
 */
export type PaymentRefundedEvent = EventEnvelope<PaymentRefundedPayload>;

/**
 * Type guard to check if an event is a PaymentRefundedEvent
 *
 * @param event - The event to check
 * @returns True if the event is a PaymentRefundedEvent
 */
export function isPaymentRefundedEvent(
  event: EventEnvelope<unknown>
): event is PaymentRefundedEvent {
  return event.type === PAYMENT_REFUNDED_EVENT;
}

/**
 * Factory function to create a PaymentRefundedEvent
 *
 * Validates required fields and generates a complete event envelope.
 *
 * @param payload - The event payload
 * @param metadata - Event metadata
 * @param tenantContext - Tenant context
 * @returns Complete event envelope
 * @throws {Error} If required fields are missing or invalid
 */
export function createPaymentRefundedEvent(
  payload: PaymentRefundedPayload,
  metadata: EventEnvelope<unknown>['metadata'],
  tenantContext: EventEnvelope<unknown>['tenantContext']
): PaymentRefundedEvent {
  // Validate critical required fields
  if (!payload.paymentId) {
    throw new Error('PaymentRefundedEvent: paymentId is required');
  }
  if (!payload.patientId) {
    throw new Error('PaymentRefundedEvent: patientId is required');
  }
  if (!payload.organizationId) {
    throw new Error('PaymentRefundedEvent: organizationId is required');
  }
  if (!payload.clinicId) {
    throw new Error('PaymentRefundedEvent: clinicId is required');
  }
  if (!payload.tenantId) {
    throw new Error('PaymentRefundedEvent: tenantId is required');
  }
  if (payload.refundAmount === undefined || payload.refundAmount === null) {
    throw new Error('PaymentRefundedEvent: refundAmount is required');
  }
  if (payload.refundAmount <= 0) {
    throw new Error('PaymentRefundedEvent: refundAmount must be greater than zero');
  }
  if (payload.originalAmount === undefined || payload.originalAmount === null) {
    throw new Error('PaymentRefundedEvent: originalAmount is required');
  }
  if (payload.originalAmount <= 0) {
    throw new Error('PaymentRefundedEvent: originalAmount must be greater than zero');
  }
  if (payload.refundAmount > payload.originalAmount) {
    throw new Error(
      `PaymentRefundedEvent: refundAmount (${payload.refundAmount}) cannot exceed originalAmount (${payload.originalAmount})`
    );
  }
  if (!payload.currency || payload.currency.trim().length === 0) {
    throw new Error('PaymentRefundedEvent: currency is required and cannot be empty');
  }
  if (!payload.refundReason) {
    throw new Error('PaymentRefundedEvent: refundReason is required');
  }
  if (!payload.refundedBy) {
    throw new Error('PaymentRefundedEvent: refundedBy is required');
  }
  if (!payload.refundDate) {
    throw new Error('PaymentRefundedEvent: refundDate is required');
  }
  if (!payload.timestamp) {
    throw new Error('PaymentRefundedEvent: timestamp is required');
  }

  return {
    id: crypto.randomUUID() as UUID,
    type: PAYMENT_REFUNDED_EVENT,
    version: PAYMENT_REFUNDED_VERSION,
    occurredAt: new Date(),
    payload,
    metadata,
    tenantContext,
  };
}

// ============================================================================
// 5. INVOICE OVERDUE EVENT
// ============================================================================

/**
 * Invoice overdue event payload
 *
 * Published when an invoice becomes overdue (past due date without full payment).
 * Consumed by automation engine (overdue reminders, escalation workflows),
 * analytics (AR aging reports), and patient portal (payment notifications).
 *
 * @example
 * ```typescript
 * const payload: InvoiceOverduePayload = {
 *   invoiceId: '123e4567-e89b-12d3-a456-426614174000',
 *   invoiceNumber: 'INV-2025-001234',
 *   patientId: 'patient-123',
 *   patientName: 'John Doe',
 *   organizationId: 'org-789',
 *   clinicId: 'clinic-101',
 *   tenantId: 'tenant-789',
 *   dueDate: '2025-12-21T10:00:00Z',
 *   daysOverdue: 15,
 *   outstandingBalance: 928.00,
 *   totalAmount: 1428.00,
 *   currency: 'RON',
 *   lastReminderDate: '2025-12-30T10:00:00Z',
 *   reminderCount: 1,
 *   timestamp: '2026-01-05T10:00:00Z',
 * };
 * ```
 */
export interface InvoiceOverduePayload {
  /** Invoice identifier */
  invoiceId: UUID;

  /** Invoice number for display */
  invoiceNumber: string;

  /** Patient who owes the payment */
  patientId: UUID;

  /** Patient name for display purposes */
  patientName: string;

  /** Organization ID (tenant context) */
  organizationId: OrganizationId;

  /** Clinic ID */
  clinicId: ClinicId;

  /** Unified tenant identifier for data partitioning */
  tenantId: string;

  /** Original due date */
  dueDate: ISODateString;

  /** Number of days overdue */
  daysOverdue: number;

  /** Outstanding balance (unpaid amount) */
  outstandingBalance: number;

  /** Total invoice amount */
  totalAmount: number;

  /** Currency code (ISO 4217) */
  currency: CurrencyCode;

  /** Date of last reminder sent (if any) */
  lastReminderDate?: ISODateString;

  /** Number of reminders sent */
  reminderCount?: number;

  /** Patient contact email */
  patientEmail?: string;

  /** Patient contact phone */
  patientPhone?: string;

  /** Provider ID associated with the invoice */
  providerId?: UUID;

  /** Provider name for display */
  providerName?: string;

  /** Aging bucket (30/60/90/120+ days) */
  agingBucket?: '0-30' | '31-60' | '61-90' | '91-120' | '120+';

  /** Whether this is the first overdue notice */
  isFirstNotice?: boolean;

  /** Next escalation action (if any) */
  nextAction?: string;

  /** Timestamp when invoice became/was detected as overdue */
  timestamp: ISODateString;

  /** Custom metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Invoice overdue event envelope
 */
export type InvoiceOverdueEvent = EventEnvelope<InvoiceOverduePayload>;

/**
 * Type guard to check if an event is an InvoiceOverdueEvent
 *
 * @param event - The event to check
 * @returns True if the event is an InvoiceOverdueEvent
 */
export function isInvoiceOverdueEvent(
  event: EventEnvelope<unknown>
): event is InvoiceOverdueEvent {
  return event.type === INVOICE_OVERDUE_EVENT;
}

/**
 * Factory function to create an InvoiceOverdueEvent
 *
 * Validates required fields and generates a complete event envelope.
 *
 * @param payload - The event payload
 * @param metadata - Event metadata
 * @param tenantContext - Tenant context
 * @returns Complete event envelope
 * @throws {Error} If required fields are missing or invalid
 */
export function createInvoiceOverdueEvent(
  payload: InvoiceOverduePayload,
  metadata: EventEnvelope<unknown>['metadata'],
  tenantContext: EventEnvelope<unknown>['tenantContext']
): InvoiceOverdueEvent {
  // Validate critical required fields
  if (!payload.invoiceId) {
    throw new Error('InvoiceOverdueEvent: invoiceId is required');
  }
  if (!payload.invoiceNumber || payload.invoiceNumber.trim().length === 0) {
    throw new Error('InvoiceOverdueEvent: invoiceNumber is required and cannot be empty');
  }
  if (!payload.patientId) {
    throw new Error('InvoiceOverdueEvent: patientId is required');
  }
  if (!payload.patientName || payload.patientName.trim().length === 0) {
    throw new Error('InvoiceOverdueEvent: patientName is required and cannot be empty');
  }
  if (!payload.organizationId) {
    throw new Error('InvoiceOverdueEvent: organizationId is required');
  }
  if (!payload.clinicId) {
    throw new Error('InvoiceOverdueEvent: clinicId is required');
  }
  if (!payload.tenantId) {
    throw new Error('InvoiceOverdueEvent: tenantId is required');
  }
  if (!payload.dueDate) {
    throw new Error('InvoiceOverdueEvent: dueDate is required');
  }
  if (payload.daysOverdue === undefined || payload.daysOverdue === null) {
    throw new Error('InvoiceOverdueEvent: daysOverdue is required');
  }
  if (payload.daysOverdue < 0) {
    throw new Error('InvoiceOverdueEvent: daysOverdue cannot be negative');
  }
  if (payload.outstandingBalance === undefined || payload.outstandingBalance === null) {
    throw new Error('InvoiceOverdueEvent: outstandingBalance is required');
  }
  if (payload.outstandingBalance <= 0) {
    throw new Error('InvoiceOverdueEvent: outstandingBalance must be greater than zero for overdue invoices');
  }
  if (payload.totalAmount === undefined || payload.totalAmount === null) {
    throw new Error('InvoiceOverdueEvent: totalAmount is required');
  }
  if (payload.totalAmount <= 0) {
    throw new Error('InvoiceOverdueEvent: totalAmount must be greater than zero');
  }
  if (payload.outstandingBalance > payload.totalAmount) {
    throw new Error(
      `InvoiceOverdueEvent: outstandingBalance (${payload.outstandingBalance}) cannot exceed totalAmount (${payload.totalAmount})`
    );
  }
  if (!payload.currency || payload.currency.trim().length === 0) {
    throw new Error('InvoiceOverdueEvent: currency is required and cannot be empty');
  }
  if (!payload.timestamp) {
    throw new Error('InvoiceOverdueEvent: timestamp is required');
  }

  return {
    id: crypto.randomUUID() as UUID,
    type: INVOICE_OVERDUE_EVENT,
    version: INVOICE_OVERDUE_VERSION,
    occurredAt: new Date(),
    payload,
    metadata,
    tenantContext,
  };
}

// ============================================================================
// 6. LEDGER ENTRY CREATED EVENT
// ============================================================================

/**
 * Ledger entry created event payload
 *
 * Published when a new ledger entry is created for double-entry accounting.
 * Critical for maintaining financial integrity, audit trails, and accounting
 * system integration (QuickBooks, Xero, etc.).
 *
 * Every financial transaction creates two ledger entries (debit and credit)
 * to maintain the accounting equation: Assets = Liabilities + Equity.
 *
 * @example
 * ```typescript
 * const payload: LedgerEntryCreatedPayload = {
 *   ledgerEntryId: 'ledger-123',
 *   invoiceId: '123e4567-e89b-12d3-a456-426614174000',
 *   paymentId: 'payment-789',
 *   organizationId: 'org-789',
 *   clinicId: 'clinic-101',
 *   tenantId: 'tenant-789',
 *   entryType: 'DEBIT',
 *   account: '1100 - Accounts Receivable',
 *   accountCode: '1100',
 *   amount: 1428.00,
 *   currency: 'RON',
 *   description: 'Patient invoice INV-2025-001234',
 *   referenceId: '123e4567-e89b-12d3-a456-426614174000',
 *   referenceType: 'INVOICE',
 *   timestamp: '2025-11-21T10:00:00Z',
 * };
 * ```
 */
export interface LedgerEntryCreatedPayload {
  /** Unique ledger entry identifier */
  ledgerEntryId: UUID;

  /** Associated invoice ID (if applicable) */
  invoiceId?: UUID;

  /** Associated payment ID (if applicable) */
  paymentId?: UUID;

  /** Organization ID (tenant context) */
  organizationId: OrganizationId;

  /** Clinic ID */
  clinicId: ClinicId;

  /** Unified tenant identifier for data partitioning */
  tenantId: string;

  /** Entry type: DEBIT or CREDIT */
  entryType: LedgerEntryType;

  /** Account name/description */
  account: string;

  /** Account code or number in chart of accounts */
  accountCode: string;

  /** Entry amount (always positive, direction indicated by entryType) */
  amount: number;

  /** Currency code (ISO 4217) */
  currency: CurrencyCode;

  /** Entry description */
  description: string;

  /** Reference to source transaction ID */
  referenceId: UUID;

  /** Reference type (INVOICE, PAYMENT, REFUND, ADJUSTMENT, etc.) */
  referenceType: 'INVOICE' | 'PAYMENT' | 'REFUND' | 'ADJUSTMENT' | 'TRANSFER' | 'OTHER';

  /** Fiscal period (e.g., '2025-11' for November 2025) */
  fiscalPeriod?: string;

  /** Fiscal year */
  fiscalYear?: number;

  /** Journal entry ID (groups related debits and credits) */
  journalEntryId?: UUID;

  /** Whether entry is posted to general ledger */
  isPosted?: boolean;

  /** User who created the entry */
  createdBy?: UUID;

  /** Creator name for display */
  createdByName?: string;

  /** Entry notes */
  notes?: string;

  /** Timestamp when ledger entry was created */
  timestamp: ISODateString;

  /** Custom metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Ledger entry created event envelope
 */
export type LedgerEntryCreatedEvent = EventEnvelope<LedgerEntryCreatedPayload>;

/**
 * Type guard to check if an event is a LedgerEntryCreatedEvent
 *
 * @param event - The event to check
 * @returns True if the event is a LedgerEntryCreatedEvent
 */
export function isLedgerEntryCreatedEvent(
  event: EventEnvelope<unknown>
): event is LedgerEntryCreatedEvent {
  return event.type === LEDGER_ENTRY_CREATED_EVENT;
}

/**
 * Factory function to create a LedgerEntryCreatedEvent
 *
 * Validates required fields and generates a complete event envelope.
 *
 * @param payload - The event payload
 * @param metadata - Event metadata
 * @param tenantContext - Tenant context
 * @returns Complete event envelope
 * @throws {Error} If required fields are missing or invalid
 */
export function createLedgerEntryCreatedEvent(
  payload: LedgerEntryCreatedPayload,
  metadata: EventEnvelope<unknown>['metadata'],
  tenantContext: EventEnvelope<unknown>['tenantContext']
): LedgerEntryCreatedEvent {
  // Validate critical required fields
  if (!payload.ledgerEntryId) {
    throw new Error('LedgerEntryCreatedEvent: ledgerEntryId is required');
  }
  if (!payload.organizationId) {
    throw new Error('LedgerEntryCreatedEvent: organizationId is required');
  }
  if (!payload.clinicId) {
    throw new Error('LedgerEntryCreatedEvent: clinicId is required');
  }
  if (!payload.tenantId) {
    throw new Error('LedgerEntryCreatedEvent: tenantId is required');
  }
  if (!payload.entryType) {
    throw new Error('LedgerEntryCreatedEvent: entryType is required');
  }
  if (payload.entryType !== 'DEBIT' && payload.entryType !== 'CREDIT') {
    throw new Error('LedgerEntryCreatedEvent: entryType must be either DEBIT or CREDIT');
  }
  if (!payload.account || payload.account.trim().length === 0) {
    throw new Error('LedgerEntryCreatedEvent: account is required and cannot be empty');
  }
  if (!payload.accountCode || payload.accountCode.trim().length === 0) {
    throw new Error('LedgerEntryCreatedEvent: accountCode is required and cannot be empty');
  }
  if (payload.amount === undefined || payload.amount === null) {
    throw new Error('LedgerEntryCreatedEvent: amount is required');
  }
  if (payload.amount <= 0) {
    throw new Error('LedgerEntryCreatedEvent: amount must be greater than zero');
  }
  if (!payload.currency || payload.currency.trim().length === 0) {
    throw new Error('LedgerEntryCreatedEvent: currency is required and cannot be empty');
  }
  if (!payload.description || payload.description.trim().length === 0) {
    throw new Error('LedgerEntryCreatedEvent: description is required and cannot be empty');
  }
  if (!payload.referenceId) {
    throw new Error('LedgerEntryCreatedEvent: referenceId is required');
  }
  if (!payload.referenceType) {
    throw new Error('LedgerEntryCreatedEvent: referenceType is required');
  }
  if (!payload.timestamp) {
    throw new Error('LedgerEntryCreatedEvent: timestamp is required');
  }

  return {
    id: crypto.randomUUID() as UUID,
    type: LEDGER_ENTRY_CREATED_EVENT,
    version: LEDGER_ENTRY_CREATED_VERSION,
    occurredAt: new Date(),
    payload,
    metadata,
    tenantContext,
  };
}
