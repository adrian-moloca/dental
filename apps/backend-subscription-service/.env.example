# ==============================================================================
# BACKEND SUBSCRIPTION SERVICE - ENVIRONMENT CONFIGURATION
# ==============================================================================
#
# Copy this file to .env.local for local development or configure for your
# target environment (staging/production).
#
# CRITICAL: Never commit .env files with real credentials to version control.
#
# ==============================================================================

# ==============================================================================
# APPLICATION CONFIGURATION
# ==============================================================================

# Environment: development | staging | production | test
# - development: Local development with debug logging and Swagger enabled
# - staging: Pre-production environment with production-like settings
# - production: Production environment with strict security and minimal logging
# - test: Automated testing environment
NODE_ENV=development

# Service port (default: 3311)
# - Local development: 3311
# - Docker container: 3311 (internal)
# - Production: Use environment-specific port or load balancer
PORT=3311

# Service name (used in logs, metrics, and distributed tracing)
SERVICE_NAME=backend-subscription-service

# ==============================================================================
# DATABASE CONFIGURATION (PostgreSQL)
# ==============================================================================
#
# ARCHITECTURE: Subscription service uses a DEDICATED PostgreSQL database
# separate from the auth service for:
# - Independent scaling and performance tuning
# - Data isolation and security
# - Simplified backup and disaster recovery
# - Reduced cross-service coupling
#
# LOCAL DEVELOPMENT:
# - Use docker-compose.dev.yml which provides postgres-subscription container
# - Default credentials: dental_user / dental_password
# - Database: dentalos_subscription
# - Port: 5434 (host) -> 5432 (container)
#
# PRODUCTION:
# - Use AWS RDS PostgreSQL or equivalent managed service
# - Enable SSL/TLS with certificate verification
# - Use strong passwords (min 32 characters, randomly generated)
# - Enable automated backups and point-in-time recovery
# ==============================================================================

# Database host
# - Local: localhost (accessing from host) or postgres-subscription (from Docker)
# - Production: RDS endpoint (e.g., dentalos-subscription.xxx.rds.amazonaws.com)
DATABASE_HOST=localhost

# Database port
# - Local: 5434 (host port) or 5432 (container internal)
# - Production: 5432 (default PostgreSQL port)
DATABASE_PORT=5434

# Database username
# - Local: dental_user
# - Production: Use least-privilege dedicated user (NOT postgres superuser)
DATABASE_USERNAME=dental_user

# Database password
# - CRITICAL: Generate strong random password for production
# - Minimum 32 characters with mix of uppercase, lowercase, numbers, symbols
# - Use secrets manager in production (AWS Secrets Manager, HashiCorp Vault)
# - Generate with: openssl rand -base64 32
DATABASE_PASSWORD=dental_password

# Database name
# - Production: Use descriptive name (e.g., dentalos_subscription_prod)
DATABASE_NAME=dentalos_subscription

# SSL/TLS Configuration
# - CRITICAL: REQUIRED in production for HIPAA compliance and data protection
# - Local development: Set to false for simplicity
# - Staging/Production: Set to true with proper certificates

# Enable SSL/TLS (true | false)
# - Local: false
# - Production: true (REQUIRED)
DATABASE_SSL=false

# Reject unauthorized SSL certificates (true | false)
# - Production: true (default, NEVER set to false in production)
# - Only set to false in development if using self-signed certificates
DATABASE_SSL_REJECT_UNAUTHORIZED=true

# SSL Certificate Authority (CA) certificate path
# - Required for cloud providers (AWS RDS, Azure PostgreSQL, GCP Cloud SQL)
# - Download from provider's documentation
# - Example: /etc/ssl/certs/rds-ca-2019-root.pem
# DATABASE_SSL_CA=/path/to/ca-certificate.crt

# Client SSL certificate (for mutual TLS - optional, higher security)
# - Provides client authentication in addition to server authentication
# - Uncomment if your database requires client certificates
# DATABASE_SSL_CERT=/path/to/client-certificate.crt
# DATABASE_SSL_KEY=/path/to/client-key.key

# Database Connection Pool Configuration
# - Controls maximum concurrent database connections
# - Too low: Performance bottleneck under load
# - Too high: Database resource exhaustion
# - Recommendation: Start with 10, monitor and adjust based on load

# Maximum connections in pool
# - Local: 10
# - Production: 20-50 (depends on instance size and expected load)
DATABASE_MAX_CONNECTIONS=10

# Connection timeout in milliseconds
# - Time to wait for connection before failing
# - Recommendation: 10000ms (10 seconds)
DATABASE_CONNECT_TIMEOUT=10000

# Database Schema Synchronization
# - CRITICAL: MUST be false in production
# - When true: TypeORM auto-creates/updates schema (DANGEROUS in production)
# - When false: Use migrations only (safe, version-controlled)
# - Local development: Can be true for rapid prototyping, but migrations preferred
DATABASE_SYNCHRONIZE=false

# Database Query Logging
# - When true: Logs all SQL queries (useful for debugging, impacts performance)
# - Local: true (helps with development and debugging)
# - Production: false (use query analysis tools instead)
DATABASE_LOGGING=false

# ==============================================================================
# REDIS CONFIGURATION
# ==============================================================================
#
# Redis is used for:
# - Session storage and caching
# - Rate limiting and throttling
# - Temporary data storage
# - Pub/sub messaging (optional)
#
# LOCAL DEVELOPMENT:
# - Use docker-compose.dev.yml which provides redis container
# - Port: 6381 (host) -> 6379 (container)
# - Password: devredis
#
# PRODUCTION:
# - Use AWS ElastiCache Redis or equivalent managed service
# - Enable in-transit encryption (TLS)
# - Enable at-rest encryption
# - Enable automated backups
# - Use Redis 7.x for best performance and features
# ==============================================================================

# Redis host
# - Local: localhost (accessing from host) or redis (from Docker)
# - Production: ElastiCache endpoint (e.g., master.dentalos-redis.xxx.cache.amazonaws.com)
REDIS_HOST=localhost

# Redis port
# - Local: 6381 (host port) or 6379 (container internal)
# - Production: 6379 (default Redis port)
REDIS_PORT=6381

# Redis password
# - CRITICAL: Use strong password in production
# - Generate with: openssl rand -base64 32
# - Local: devredis (for simplicity)
REDIS_PASSWORD=devredis

# Redis database number (0-15)
# - Use different database numbers for different environments if sharing Redis instance
# - Local: 0
# - Staging: 1
# - Production: Use dedicated Redis instance instead of different DB number
REDIS_DB=0

# Enable TLS/SSL for Redis connection (true | false)
# - CRITICAL: REQUIRED in production for data protection
# - Local: false
# - Production: true
REDIS_TLS=false

# Redis key prefix (namespace)
# - Prevents key collisions when sharing Redis instance
# - Format: dentalos:service:environment:
# - Example: dentalos:subscription:prod:
REDIS_KEY_PREFIX=dentalos:subscription:

# ==============================================================================
# JWT CONFIGURATION
# ==============================================================================
#
# JWT tokens are used for authentication and authorization.
# Subscription service validates JWT tokens issued by the auth service.
#
# CRITICAL SECURITY REQUIREMENTS:
# - JWT_ACCESS_SECRET MUST match the auth service secret
# - Use minimum 32 characters (64+ recommended for production)
# - Never commit secrets to version control
# - Rotate secrets periodically (every 90 days in production)
# - Use secrets manager in production (AWS Secrets Manager, HashiCorp Vault)
#
# ==============================================================================

# JWT Access Token Secret
# - CRITICAL: MUST be identical to auth service JWT_ACCESS_SECRET
# - Used to validate tokens issued by auth service
# - Generate with: openssl rand -base64 64
# - Local: Use shared development secret from .env.docker
# - Production: Sync with auth service via secrets manager
JWT_ACCESS_SECRET=dev-access-secret-32chars-min-123456789012

# JWT Issuer
# - Identifies who issued the token (should match auth service)
# - Used in token validation
JWT_ISSUER=dentalos-auth

# JWT Audience
# - Identifies intended recipient of the token
# - Used in token validation
JWT_AUDIENCE=dentalos-api

# ==============================================================================
# STRIPE CONFIGURATION
# ==============================================================================
#
# Stripe is used for payment processing and subscription management.
#
# TEST vs PRODUCTION KEYS:
# - Test keys: sk_test_xxx (for development/staging)
# - Live keys: sk_live_xxx (for production only)
# - NEVER use live keys in development
# - NEVER commit keys to version control
#
# WEBHOOK CONFIGURATION:
# - Webhooks enable Stripe to notify your app of events (subscription created, payment failed, etc.)
# - Each environment needs separate webhook endpoints and secrets
# - Local development: Use Stripe CLI for webhook forwarding (stripe listen --forward-to localhost:3011/api/webhooks/stripe)
# - Production: Configure webhook endpoint in Stripe Dashboard
#
# SETUP INSTRUCTIONS:
# 1. Create Stripe account at https://stripe.com
# 2. Get test API key from Dashboard > Developers > API keys
# 3. Configure webhook endpoint in Dashboard > Developers > Webhooks
# 4. Copy webhook signing secret to STRIPE_WEBHOOK_SECRET
#
# ==============================================================================

# Stripe API Key
# - Local/Staging: Use test key (sk_test_xxx)
# - Production: Use live key (sk_live_xxx)
# - Get from: Stripe Dashboard > Developers > API keys
# - CRITICAL: Store in secrets manager in production
STRIPE_API_KEY=sk_test_your_test_key_here

# Stripe Webhook Signing Secret
# - Used to verify webhook authenticity and prevent tampering
# - Get from: Stripe Dashboard > Developers > Webhooks > [Your Endpoint] > Signing secret
# - Each environment needs its own webhook endpoint and secret
# - Local: Use Stripe CLI webhook secret (whsec_xxx)
# - Production: Use production webhook secret from Stripe Dashboard
STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret_here

# Stripe API Version
# - Pins Stripe API version for consistent behavior
# - Format: YYYY-MM-DD.preview_name (optional preview)
# - Check latest version: https://stripe.com/docs/api/versioning
# - Update carefully and test thoroughly when changing versions
STRIPE_API_VERSION=2024-11-20.acacia

# ==============================================================================
# CORS CONFIGURATION
# ==============================================================================
#
# Cross-Origin Resource Sharing (CORS) controls which domains can access the API.
#
# SECURITY BEST PRACTICES:
# - NEVER use * (wildcard) in production
# - Only list trusted frontend domains
# - Use HTTPS URLs in production
# - Enable credentials only if needed for cookies/auth headers
#
# LOCAL DEVELOPMENT:
# - Include all local development URLs (Vite default: 5173, Create React App: 3000)
#
# PRODUCTION:
# - Only include production frontend URLs
# - Use environment variables for different deployment environments
# - Example: https://app.dentalos.com,https://admin.dentalos.com
#
# ==============================================================================

# Allowed Origins (comma-separated, no spaces)
# - Local: http://localhost:5173,http://localhost:3000
# - Production: https://app.dentalos.com,https://admin.dentalos.com
# - CRITICAL: Never use * in production
CORS_ORIGINS=http://localhost:5173,http://localhost:3000

# Allow Credentials (true | false)
# - Set to true if frontend needs to send cookies or auth headers
# - Required for session-based authentication
# - Can be false for token-based auth without cookies
CORS_CREDENTIALS=true

# ==============================================================================
# RATE LIMITING CONFIGURATION
# ==============================================================================
#
# Rate limiting protects the API from abuse and ensures fair resource allocation.
#
# STRATEGY:
# - Global rate limiting: Applies to all requests
# - Per-tenant rate limiting: Prevents "noisy neighbor" problem in multi-tenant environment
#
# TUNING GUIDANCE:
# - Start with conservative limits and increase based on monitoring
# - Monitor rate limit violations in logs and metrics
# - Set alerts for high rate limit violation rates
# - Consider different limits for different API endpoints (public vs authenticated)
#
# ==============================================================================

# Global Rate Limit TTL (milliseconds)
# - Time window for rate limit calculation
# - Example: 60000 = 1 minute window
RATE_LIMIT_TTL=60000

# Global Rate Limit Max Requests
# - Maximum requests per TTL window
# - Example: 100 requests per minute
# - Recommendation: 100-500 for development, 1000-5000 for production (adjust based on load)
RATE_LIMIT_MAX_REQUESTS=100

# Per-Tenant Rate Limiting
# - Prevents one tenant from consuming all resources
# - Critical for multi-tenant SaaS applications
# - Enables fair resource allocation

# Enable Per-Tenant Rate Limiting (true | false)
# - Recommended: true for production
RATE_LIMIT_PER_TENANT_ENABLED=true

# Per-Tenant Rate Limit TTL (milliseconds)
# - Time window for tenant-specific rate limit
# - Example: 900000 = 15 minutes
# - Longer window than global limit to catch sustained abuse
RATE_LIMIT_TENANT_TTL=900000

# Per-Tenant Rate Limit Max Requests
# - Maximum requests per tenant per TTL window
# - Example: 5000 requests per 15 minutes per tenant
# - Recommendation: 5000-10000 for standard plans, higher for premium plans
RATE_LIMIT_TENANT_MAX=5000

# ==============================================================================
# LOGGING CONFIGURATION
# ==============================================================================
#
# Structured logging with different levels and formats.
#
# LOG LEVELS (from least to most verbose):
# - error: Only critical errors that require immediate attention
# - warn: Warning messages about potential issues
# - info: General informational messages (default for production)
# - debug: Detailed debugging information (use in development only)
#
# LOG FORMATS:
# - json: Structured JSON format (recommended for production, easy to parse)
# - pretty: Human-readable colorized format (recommended for development)
#
# ==============================================================================

# Log Level
# - Development: debug (detailed debugging information)
# - Staging: info (general operational information)
# - Production: warn or error (minimize noise, focus on issues)
LOG_LEVEL=info

# Log Format
# - Development: pretty (easy to read in terminal)
# - Production: json (structured, machine-parsable for log aggregation)
LOG_FORMAT=pretty

# ==============================================================================
# API DOCUMENTATION
# ==============================================================================
#
# Swagger/OpenAPI documentation provides interactive API documentation.
#
# SECURITY WARNING:
# - NEVER enable in production (exposes API structure and potentially sensitive information)
# - Only enable in development and staging environments
# - Access at: http://localhost:3011/api/docs
#
# ==============================================================================

# Enable Swagger API Documentation (true | false)
# - Development: true (helpful for testing and development)
# - Staging: true (useful for integration testing)
# - Production: false (CRITICAL: security risk if exposed)
SWAGGER_ENABLED=true

# ==============================================================================
# HEALTH CHECK CONFIGURATION
# ==============================================================================
#
# Health checks enable monitoring systems to detect service degradation.
#
# ENDPOINTS:
# - /health/liveness: Is the service running? (used by Kubernetes liveness probe)
# - /health/readiness: Is the service ready to accept traffic? (used by Kubernetes readiness probe)
# - /health/detailed: Detailed health information including dependencies
#
# MONITORING:
# - Configure alerts based on health check failures
# - Use health checks in load balancer configuration
# - Monitor trends in resource usage (memory, disk)
#
# ==============================================================================

# Memory Heap Threshold (MB)
# - Triggers unhealthy status when heap memory exceeds threshold
# - Helps detect memory leaks before service crashes
# - Recommendation: 150MB for typical Node.js services, adjust based on actual usage
HEALTH_CHECK_MEMORY_HEAP_THRESHOLD=150

# Disk Usage Threshold (percentage as decimal)
# - Triggers unhealthy status when disk usage exceeds threshold
# - Example: 0.9 = 90% disk usage
# - Helps prevent disk space exhaustion
HEALTH_CHECK_DISK_THRESHOLD=0.9

# ==============================================================================
# SHUTDOWN CONFIGURATION
# ==============================================================================
#
# Graceful shutdown ensures in-flight requests complete before service stops.
#
# PROCESS:
# 1. Receive shutdown signal (SIGTERM, SIGINT)
# 2. Stop accepting new requests
# 3. Wait for in-flight requests to complete (up to timeout)
# 4. Close database connections
# 5. Close Redis connections
# 6. Exit process
#
# KUBERNETES CONSIDERATIONS:
# - Set terminationGracePeriodSeconds higher than SHUTDOWN_TIMEOUT
# - Recommended: SHUTDOWN_TIMEOUT=10000, terminationGracePeriodSeconds=30
#
# ==============================================================================

# Graceful Shutdown Timeout (milliseconds)
# - Maximum time to wait for in-flight requests to complete
# - After timeout, service forcefully terminates
# - Recommendation: 10000ms (10 seconds)
SHUTDOWN_TIMEOUT=10000
